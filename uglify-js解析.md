# uglify-js解析

> - A [parser](http://lisperator.net/uglifyjs/parser) which produces an [abstract syntax tree (AST)](http://lisperator.net/uglifyjs/ast) from JavaScript code.
> - A [code generator](http://lisperator.net/uglifyjs/codegen) which outputs JavaScript code from an AST, also providing the option to get a [source map](http://lisperator.net/uglifyjs/codegen#source-map).
> - A [compressor (optimizer)](http://lisperator.net/uglifyjs/compress) — it uses the transformer API to optimize an AST into a smaller one.
> - A [mangler](http://lisperator.net/uglifyjs/mangle) — reduce names of local variables to (usually) single-letters.
> - A [scope analyzer](http://lisperator.net/uglifyjs/scope), which is a tool that augments the AST with information about where variables are defined/referenced etc.
> - A [tree walker](http://lisperator.net/uglifyjs/walk) — a simple API allowing you to do something on every node in the AST.
> - A [tree transformer](http://lisperator.net/uglifyjs/transform) — another API intended to transform the tree.



## Parser

parser 会通过给定的 JavaScript 代码片段创建一个自定义的AST( [abstract syntax tree](http://lisperator.net/uglifyjs/ast))。可以在这之前先阅读AST的部分。

```js
// it takes the source code to parse as first argument:
var ast = UglifyJS.parse("function sum(x, y){ return x + y }");

// optionally you can pass another argument with options:
var ast = UglifyJS.parse(code, {
    strict   : true,              // default is false
    filename : "Input file name", // default is null
    toplevel : ast                // also null
});
```

当参数中没有指定 **toplevel** 的时候，parser 会创建一个 **AST_Toplevel** 节点，并将代码中的所有语句放入它的 body 中。另外，想要生成正确的 source map，这种能够将多个文件解析成一个单独的 toplevel 节点的能力会非常有用。例如：

```js
var ast = UglifyJS.parse(file1_content, { filename: "file1.js" });
ast = UglifyJS.parse(file2_content, { filename: "file2.js", toplevel: ast });
ast = UglifyJS.parse(file3_content, { filename: "file3.js", toplevel: ast });

// or in general, if in `files` array you have the list of files:
var ast = null;
files.forEach(function(file){
    var code = fs.readFileSync(file, "utf8");
    ast = UglifyJS.parse(code, { filename: file, toplevel: ast });
});
```

## the syntax tree (AST)

Each definition starts with the node name (i.e. AST_Node), followed by a list of own properties in parens (if it has any), followed by a string description and followed by any subclasses (if there are any). Nodes inherit properties from the base classes; for example since the **start** and **end** properties are defined in the base class AST_Node, then every node contains those properties.

每个定义从节点名字开始（例如 AST_Node），然后是一系列属性（如果有的话），然后是一串描述，然后是subclasses（如果有的话）。节点会继承基类的属性，例如 start 和 end 在一开始的基类 AST_Node被定义了，那么每个节点都包含这些属性。

The parser will instantiate the most specific subclass; for example you will never find an object of type AST_Node in the AST; that's just the base class. You won't find an AST_Statement either, since every kind of statement has its own dedicated subclass.

### The AST nodes

The following hierarchy is generated by your browser using introspection from the UglifyJS objects. Click a node to get a brief description of it. [See below](http://lisperator.net/uglifyjs/ast#tokens) for some information on `AST_Token`, also take a look at the [scope analyzer](http://lisperator.net/uglifyjs/scope) for more information about properties in red and `SymbolDef`.

```js
AST_Node {
  AST_Statement {
    AST_Debugger
    AST_Directive
    AST_SimpleStatement
    AST_Block {
      AST_BlockStatement
      AST_Scope {
        AST_Toplevel
        AST_Lambda {
          AST_Accessor
          AST_Function
          AST_Defun
        }
      }
      AST_Switch
      AST_SwitchBranch {
        AST_Default
        AST_Case
      }
      AST_Try
      AST_Catch
      AST_Finally
    }
    AST_EmptyStatement
    AST_StatementWithBody {
      AST_LabeledStatement
      AST_IterationStatement {
        AST_DWLoop {
          AST_Do
          AST_While
        }
        AST_For
        AST_ForIn
      }
      AST_With
      AST_If
    }
    AST_Jump {
      AST_Exit {
        AST_Return
        AST_Throw
      }
      AST_LoopControl {
        AST_Break
        AST_Continue
      }
    }
    AST_Definitions {
      AST_Var
      AST_Const
    }
  }
  AST_VarDef
  AST_Call {
    AST_New
  }
  AST_Seq
  AST_PropAccess {
    AST_Dot
    AST_Sub
  }
  AST_Unary {
    AST_UnaryPrefix
    AST_UnaryPostfix
  }
  AST_Binary {
    AST_Assign
  }
  AST_Conditional
  AST_Array
  AST_Object
  AST_ObjectProperty {
    AST_ObjectKeyVal
    AST_ObjectSetter
    AST_ObjectGetter
  }
  AST_Symbol {
    AST_SymbolAccessor
    AST_SymbolDeclaration {
      AST_SymbolVar {
        AST_SymbolFunarg
      }
      AST_SymbolConst
      AST_SymbolDefun
      AST_SymbolLambda
      AST_SymbolCatch
    }
    AST_Label
    AST_SymbolRef
    AST_LabelRef
    AST_This
  }
  AST_Constant {
    AST_String
    AST_Number
    AST_RegExp
    AST_Atom {
      AST_Null
      AST_NaN
      AST_Undefined
      AST_Hole
      AST_Infinity
      AST_Boolean {
        AST_False
        AST_True
      }
    }
  }
}
```

### The tokenizer

For a higher-level operation, the parser works concomitantly with a tokenizer. The tokenizer is initialized to the stream of the source code text and reads one token at a time, producing an **AST_Token** object which has the following properties:

- **type** — the type of this token; can be "num", "string", "regexp", "operator", "punc", "atom", "name", "keyword", "comment1" or "comment2".

  "comment1" and "comment2" are for single-line, respectively multi-line comments.

- **file** — the name of the file where this token originated from. Useful when compressing multiple files at once to generate the proper source map.

- **value** — the "value" of the token; that's additional information and depends on the token type: "num", "string" and "regexp" tokens you get their literal value; for "operator" you get the operator; for "punc" it's the punctuation sign (parens, comma, semicolon etc); for "atom", "name" and "keyword" it's the name of the identifier, and for comments it's the body of the comment (excluding the initial "//" and "/*".

- **line** and **col** — the location of this token in the original code. The line is 1-based index, and the column is the 0-based index.

- **pos** and **endpos** — the zero-based start and end positions of this token in the original text.

- **nlb** — short for "newline before", it's a boolean that tells us whether there was a newline before this node in the original source. It helps for automatic semicolon insertion. For multi-line comments in particular this will be set to true if there either was a newline before this comment, or if this comment contains a newline.

- **comments_before** — this doesn't apply for comment tokens, but for all other token types it will be an array of comment tokens that were found before.

The **start** and **end** properties of AST nodes are **AST_Token** objects and tell you where that node begins and ends. The **AST_Toplevel** is the single node that might start in one file and end in another (when parsing multiple files); the parser will properly update its **end** property.



## scope analyzer

UglifyJS包含一个作用域分析器，可以识别出 变量/方法 的定义和引用等。你需要在压缩和混淆之前手动调用：

```js
toplevel.figure_out_scope();
```

figure_out_scope 方法只在 **AST_Toplevel** 节点定义了。

#### Methods

Several methods do meaningful things after a call to `figure_out_scope`:

- **AST_Scope::find_variable(name)** — looks up the variable by name and if found it returns the associated [SymbolDef](http://lisperator.net/uglifyjs/scope#SymbolDef).
- **AST_Scope::references(def)** — returns non-null if this scope references the given SymbolDef.
- **AST_Symbol::unmangleable()** — returns `true` if this symbol cannot be renamed (it's either global, undeclared, or defined in scope where `eval` or `with` are in use.
- **AST_Symbol::unreferenced()** — returns `true` if this symbol is not referenced.
- **AST_Symbol::undeclared()** — returns `true` if this symbol is undeclared.
- **AST_Symbol::global()** — returns `true` if this symbol is defined in the global (toplevel) scope.
- **AST_Symbol::definition()** — returns the associated [SymbolDef](http://lisperator.net/uglifyjs/scope#SymbolDef) for this symbol.

#### Internals

figure_out_scope 会为节点补充额外的信息：

##### In **AST_Scope** nodes

- **directives** — an array of directives that appear in this scope.
- **variables** — a mapping from name to [SymbolDef](http://lisperator.net/uglifyjs/scope#SymbolDef) object for all definitions in this scope, including functions.
- **functions** — a like **variables** but only for function declarations.
- **uses_with** — becomes `true` if the `with` statement is used in this scope or any subscopes.
- **uses_eval** — becomes `true` if a direct call to the global `eval` is seen in this scope or any subscope.
- **parent_scope** — a pointer to the parent scope, or null of this is the toplevel scope.
- **enclosed** — a list of [SymbolDef](http://lisperator.net/uglifyjs/scope#SymbolDef)-s defined in this or in the outer scopes which are used from this or from inner scopes.

##### In **AST_Symbol** nodes

- **scope** — pointer to the *current* scope.
- **thedef** — pointer to the [SymbolDef](http://lisperator.net/uglifyjs/scope#SymbolDef) associated with this symbol

##### In **AST_LabelRef** nodes

- **scope** — pointer to the *current* scope.
- **thedef** — pointer to the **AST_Label** declaration that this symbol refers to

#### Symbol definitions

parsing之后，可以通过调用 `toplevel.figure_out_scope()` 来补充 AST 中额外的信息。

改方法会为每个 symbol 创建一个独一无二的定义。看下面的代码：

```js
function f(x) {
  if (something) {
    var x = 10;
  }
  var x = 20;
}
```

代码中的x是相同的变量吗？他们应该是相同的，虽然在语法树中他们是不同的 **AST_SymbolDeclaration** 节点。作用域分析器会创建一个单独的定义，然后把他们每个都指向同一个定义。这个定义是一个 **SymbolDef** 对象，它有以下属性：

- **name** — 原始的 symbol 名字
- **orig** — 由 AST_SymbolDeclaration 组成的数组，记录该变量都是在哪定义的，以上面的例子来讲的话，就是包含三个x。
- **scope** — 指向定义位置所在的 **AST_Scope**。
- **references** — an array of **AST_SymbolRef** nodes that were determined to point to this definition.
- **global** — boolean, 告诉我们是否是全局定义。
- **undeclared** — boolean, tells us if this is an undeclared definition (more below about undeclared names).
- **constant** — boolean, true if this is a constant definition (occurring in `const`).
- **mangled_name** — the mangled name for this node, created by `toplevel.mangle_names()`. If present, the code generator will use this name when printing symbols.

当它看见一个未声明的 symbol，就像下面代码中 Q 一样：

```
function f(x) {
  return Q + Q + x;
}
```

UglifyJS 仍然会创建一个 SymbolDef， 但是会把它标记成”undeclared“。这是为了保持一致性，这样每个 symbol 的  `definition()` 方法都会返回有用的信息。还有一种可能会有用的地方，就是不同的程序会追踪未声明的全局变量，这样就可以通过 SymbolDef's 的 **references**属性中找到。

## the compressor

compressor 是一个 [tree transformer](http://lisperator.net/uglifyjs/transform) ，通过在 AST 上应用各种优化方案来减少代码体积：

- 合并连续的 `var`/`const` 语句。
- 使用”逗号“合并连续的简单的语句。
- 弃掉没用过的变量/函数。
- 优化 if 语句和条件表达式
- 评估常量表达式
- 移除不可达代码（unreachable code）
- 其它……

### SYNOPSIS

```js
ast = UglifyJS.parse(code);
ast.figure_out_scope();
compressor = UglifyJS.Compressor({ ...compressor_options... });
ast = ast.transform(compressor);
code = ast.print_to_string(); // 得到压缩后的代码
```

上面提到了 `TreeTransformer`：

> The tree transformer is a special case of a [tree walker](http://lisperator.net/uglifyjs/walk). In fact it even inherits from **TreeWalker** and you can use the same methods, but initialization and visitor protocol are a bit different.

The default options should yield to best compression on most scripts. The following options are supported:

在大多数脚本中，默认选项已经是最佳压缩方案了，支持一下选项：

```js
sequences     : true,  // 用“逗号运算符”连接连续的语句
properties    : true,  // 优化属性访问: a["foo"] → a.foo
dead_code     : true,  // 丢弃无法访问的代码
drop_debugger : true,  // 丢弃 “debugger” 语句
unsafe        : false, // 一些不安全的优化 (see below)
conditionals  : true,  // 优化if语句和条件表达式
comparisons   : true,  // 优化比较
evaluate      : true,  // 计算常量表达式
booleans      : true,  // 优化布尔表达式
loops         : true,  // 优化循环
unused        : true,  // 删除未使用的变量/函数
hoist_funs    : true,  // 提升函数声明
hoist_vars    : false, // 提升变量声明
if_return     : true,  // 优化 if 语句，然后返回 return/continue
join_vars     : true,  // 整合var声明
cascade       : true,  // 尝试按顺序将`right`级联为`left`
side_effects  : true,  // 删除 side-effect-free 语句
warnings      : true,  // 警告潜在的危险的optimizations/code
global_defs   : {}     // 全局定义
```

### Global definitions

可以使用此功能来有条件地删除代码. 如果你传入下面的变量：

```js
global_defs: {
    DEBUG: false
}
```

compresser会假定这是一个常量定义，会将下面这种这种无法访问的代码丢弃。

```js
if (DEBUG) {
    ...
}
```

这样在生产环境构建的时候，丢弃掉只有开发环境所需要的代码。

在以前的UglifyJS版本中，你实际上必须为此类定义传递AST，但在版本2中则不再如此，只需传递你希望全局定义的JavaScript常量即可。



## `TreeWalker`

#### 范例

```js
function visitor(node, descend) {
   ...
};
var walker = new UglifyJS.TreeWalker(visitor);
ast.walk(walker);
```

UglifyJS provides a `TreeWalker` object and every node has a `walk` method that given a walker will apply your visitor to each node in the tree. Your visitor can return a non-falsy value in order to prevent descending the current node.

UglifyJS 提供一个 `TreeWalker` 对象，每一个节点都有一个 `walk` 方法，使得传入的 walker 能够将你的visitor 应用到语法树的每一个节点。你的 visitor 可以返回一个非 false 的值来阻止从当前节点继续往下走。

### Avoiding diving into nodes

下面是一个例子，阐述如何打印出所有的函数声明：

```js
var code = "function foo() {\n\
  function x(){}\n\
  function y(){}\n\
}\n\
function bar() {}";
var toplevel = UglifyJS.parse(code);
var walker = new UglifyJS.TreeWalker(function(node){
    if (node instanceof UglifyJS.AST_Defun) {
        // string_template is a cute little function that UglifyJS uses for warnings
        console.log(UglifyJS.string_template("Found function {name} at {line},{col}", {
            name: node.name.name,
            line: node.start.line,
            col: node.start.col
        }));
    }
});
toplevel.walk(walker);
```

上面的例子定义了两个 toplevel 函数：foo 和 bar，以及在foo中内嵌了两个函数：x和y。执行上面的代码，会得到下面的输出结果：

```js
Found function foo at 1,0
Found function x at 2,2
Found function y at 3,2
Found function bar at 5,0
```

如果我们只想要打印出toplevel的函数呢？实际上有两种解决方法：

(1) 检查visitor的父级node，如果不是**AST_Toplevel**则不显示。

(2) simply avoid descending into functions. 

在本例中，后者更方便一些。为了避免 descending，visitor 必须返回一个非false的值。下面的版本会只显示“foo”和“bar”：

```js
var code = "function foo() {\n\
  function x(){}\n\
  function y(){}\n\
}\n\
function bar() {}";
var toplevel = UglifyJS.parse(code);
var walker = new UglifyJS.TreeWalker(function(node){
    if (node instanceof UglifyJS.AST_Defun) {
        // string_template is a cute little function that UglifyJS uses for warnings
        console.log(UglifyJS.string_template("Found function {name} at {line},{col}", {
            name: node.name.name,
            line: node.start.line,
            col: node.start.col
        }));
        return true; // ← that's the modification
    }
});
toplevel.walk(walker);
```

### Determine the parent node(s)

AST在节点中没有维持 child→parent 的链接。不过 walker可以简单地跟踪上层节点，并且提供了API：

- **walker.parent()** — 返回当前节点的父节点
- **walker.stack** — 一个数组，元素是所有的通向当前节点的节点。数组最后一个元素就是当前的节点本身。
- **walker.find_parent(type)** — 查找给定类型的节点的最里面的父节点。type 必须是一个节点构造函数，例如  **AST_Scope**。

下面的例子是如何打印出在函数调用中参数为字符串的：

```js
var code = "function f(){}\n\
var x = 'a string';\n\
y = 'foo' + 'bar' + x;\n\
f('a', 'b', (x + 'z'), y, 'c');\n\
";
var toplevel = UglifyJS.parse(code);
var walker = new UglifyJS.TreeWalker(function(node){
    if (node instanceof UglifyJS.AST_String) {
        var p = walker.parent();
        if (p instanceof UglifyJS.AST_Call && node !== p.expression) {
            console.log("Found string: %s at %d,%d", node.getValue(),
                        node.start.line, node.start.col);
        }
    }
});
toplevel.walk(walker);
```

结果是：

```js
Found string: a at 4,2
Found string: b at 4,7
Found string: c at 4,26
```

“a”，“b”和“c”是直接在AST_Call下面出现的字符串。如果我们也想要“z”的话，就用到了find_parent：

```js
var code = "function f(){}\n\
var x = 'a string';\n\
y = 'foo' + 'bar' + x;\n\
f('a', 'b', (x + 'z'), y, 'c');\n\
";
var toplevel = UglifyJS.parse(code);
var walker = new UglifyJS.TreeWalker(function(node){
    if (node instanceof UglifyJS.AST_String) {
        var p = walker.find_parent(UglifyJS.AST_Call);
        if (p && node !== p.expression) {
            console.log("Found string: %s at %d,%d", node.getValue(),
                        node.start.line, node.start.col);
        }
    }
});
toplevel.walk(walker);
```

### Another way: descend manually into call nodes

有很多种方法来实现。可能通过走我们自己来追踪特定的父节点可能会更有效或者更快一些。UglifyJS在一些地方这样做。你的访问器会接收一个第二参数，是一个方法，会停止在当前节点，然后返回到当前visitor：

```js
var code = "function f(){}\n\
var x = 'a string';\n\
y = 'foo' + 'bar' + x;\n\
f('a', 'b', (x + 'z'), y, 'c');\n\
";
var toplevel = UglifyJS.parse(code);
var call_expression = null;
var walker = new UglifyJS.TreeWalker(function(node, descend){
    if (node instanceof UglifyJS.AST_Call) {
        var tmp = call_expression;
        call_expression = node;
        descend();
        call_expression = tmp;
        return true; // prevent descending again
    }
    if (node instanceof UglifyJS.AST_String && call_expression) {
        console.log("Found string: %s at %d,%d", node.getValue(),
                    node.start.line, node.start.col);
    }
});
toplevel.walk(walker);
```

结果与上面的例子一样。这样写的优点是通过去哦们为你自己来跟踪当前的调用表达式，walker不需要查找每个字符串节点，所以可能会更快一些。但是让我们看一个同样的实现，但是输入的代码不同，这里先把代码写在函数里，然后通过toString()进行了转换，这样可读性比较强一些：

```js
var code = function toplevel() {
    var a = foo("x", "y", (function(){
        var b = "stuff";
        var c = "bar";
    })(), 1, "z");
};
code = code.toString();
var toplevel = UglifyJS.parse(code);
var call_expression = null;
var walker = new UglifyJS.TreeWalker(function(node, descend){
    if (node instanceof UglifyJS.AST_Call) {
        var tmp = call_expression;
        call_expression = node;
        descend();
        call_expression = tmp;
        return true; // prevent descending again
    }
    if (node instanceof UglifyJS.AST_String && call_expression) {
        console.log("Found string: %s at %d,%d", node.getValue(),
                    node.start.line, node.start.col);
    }
});
toplevel.walk(walker);
```

这样输出的结果是：

```js
Found string: x at 2,16
Found string: y at 2,21
Found string: stuff at 3,16
Found string: bar at 4,16
Found string: z at 5,13
```

但这并不符合我们的预期，虽然父节点的类型是 AST_Call，但是 stuff 和 bar 是在另一个函数里的变量，而不是使用在调用表达式中。这样的话就不能简单地通过**find_parent()**来判断了，需要我们手动追踪指定的父节点，然后使用 **descend** 方法，这样会有些繁琐：

```js
var code = function toplevel() {
    var a = foo("x", "y", (function(){
        var b = "stuff";
        var c = "bar";
    })(), 1, "z");
};
code = code.toString();
var toplevel = UglifyJS.parse(code);
var call_expression = null;
var walker = new UglifyJS.TreeWalker(function(node, descend){
    if (node instanceof UglifyJS.AST_Call) {
        var tmp = call_expression;
        call_expression = node;
        descend();
        call_expression = tmp;
        return true; // prevent descending again
    }
    if (node instanceof UglifyJS.AST_Lambda) { // ← 这里，当遇到匿名函数，暂时忘记调用表达式
        var tmp = call_expression;
        call_expression = null;
        descend();
        call_expression = tmp;
        return true; // again, to prevent diving this node twice
    }
    if (node instanceof UglifyJS.AST_String && call_expression) {
        console.log("Found string: %s at %d,%d", node.getValue(),
                    node.start.line, node.start.col);
    }
});
toplevel.walk(walker);
```

做法很简单，当走到匿名函数的时候，暂时“忘记”当前的调用表达式。在对lambda进行降序运算后，它将恢复前面的call_expression。可能你会想，如果根本不去遍历匿名函数表达式，是不是更简单，但是这样会漏掉下面的“qwe”字符串：

```js
var a = foo("x", "y", (function(){
    var b = "stuff";
    var c = "bar";
    return x("qwe");
})(), 1, "z");
```

### API reference

通过传递进一个 visitor 方法来构建一个  **TreeWalker** 。visitor 接收两个参数：当前节点node，和一个 descend 方法，可以手动调用来阻止节点继续遍历。如果 visitor 返回true，那么 TreeWalker 本身将不会继续遍历节点。

walker 对象有下面的方法：

- **parent(n)** — n可选，默认是0。返回当前节点的第n个父节点，0代表最直接的父节点。
- **find_parent(constructor)** — 查找指定类型的最里面的父节点。
- **in_boolean_context()** — returns `true` if the result of the current node is expected in a boolean context (that is, the value of the node doesn't matter, except for its truth value).
- **loopcontrol_target(label)** — returns the block that the specified label refers to. If **label** is null, returns the block that a `break`/`continue` statement in the current position would refer to.
- **has_directive(dir)** — returns a non-falsy value if the directive is in effect at the current node. Pass a complete directive value, i.e. `"use strict"` or `"use asm"`. If the directive is defined in the current scope, it returns `true`, if it's defined in an upper scope it returns the string `"up"`.

## `TreeTransformer`

tree transformer 是 tree walker 的一个特殊的案例。实际上它是继承自**TreeWalker**，你可以使用相同的方法，但是初始化和visitor定义会有一些不同。

### 范例

```js
function before(node, descend) { ... };
function after(node) { ... };
var tt = new UglifyJS.TreeTransformer(before, after);
var new_ast = ast.transform(tt);
```

两个visitor都是可选的，但是你应该至少传递一个，不然就是空跑一遍。

#### The “before” visitor

对于树中的每个节点，before visitor 会在走到当前节点的子节点之前被调用。它接收2个参数，当前节点和descend 方法。

- 如果 before visitor 返回的是 undefined：

  - if an **after** visitor exists, then the tree walker *will clone the current node*, descend into it (process children nodes) and thereafter call the **after** visitor, giving it a reference to the new node (the clone)如果 after visitor 存在，那么 tree walker 会拷贝当前节点，descend into it （处理子节点）然后调用 after visitor，穿进去新节点（拷贝后的）的引用。

  - if there is no **after** visitor, then it will just descend the current node without cloning it.

    如果没有 after visitor，那么它会只是 descend 当前的节点，而不会进行拷贝。

- If your **before** visitor returns a value, then the current node will be replaced by that value in the tree (destructive change!). The children of the current node will not be processed in this case (if you return a new node in the “before” visitor, it is expected that you did any processing for the child nodes yourself). Also, the “after” handler will not be called.

  如果 before visitor 有返回值，那么当前节点将会被这个返回值所替代（破坏性的改变！）。当前节点的子节点将不会被处理（如果你在 before visitor 返回了一个新的节点，那么也就是说你会对子节点自行处理）。所以，这时 after 将不会被调用。

#### The “after” visitor

  If you provide an **after** visitor, it will be called on any node for which the **before** visitor returned `undefined`, after the node has been cloned and its children transformed. If your **after** visitor returns a value `!== undefined`, then that value will replace the current node in the tree (that's non-destructive, since the node was cloned first).

如果你提供了一个 after visitor，如果before visitor返回为`undefined`，那么会在该节点被拷贝，子节点被转换之后被调用。如果after visitor 返回的值  `!== undefined`,那么该值会替换当前节点（这不是破坏性的，因为该节点事先被拷贝了。）

### Examples

#### Cloning a tree

首先想到的例子就是拷贝树。UglifyJS compressor 是有破坏性的，它会修改当前的树，所以如果你想使用 

compressor并且还继续保留原始的AST，那就需要拷贝一份。看下面例子：

```js
// sample AST
var ast = UglifyJS.parse("a = 1 + 2");

// this is the transformer
var deep_clone = new UglifyJS.TreeTransformer(function(node, descend){
    node = node.clone();
    // the descend function expects two arguments:
    // the node to dive into, and the tree walker
    // `this` here is the tree walker (=== deep_clone).
    // by descending into the *cloned* node, we keep the original intact
    descend(node, this);
    return node;
});

// in ast2 we'll get a deep copy of ast
var ast2 = ast.transform(deep_clone);

// let's change AST now:
ast.body[0].body.left.name = "CHANGED"; // CHANGED = 1 + 2

console.log(ast.print_to_string({ beautify: true }));
console.log(ast2.print_to_string({ beautify: true }));
```

另外，因为如果提供了after visitor， transformer本身就会拷贝节点，所以我们也可以用下面的方法拷贝整个树（甚至效率更高）：

```js
ast.transform(new UglifyJS.TreeTransformer(null, function(){}));
```

#### Consolidating strings

## the name mangler

UglifyJS can reduce names of local variables and functions usually to single-letters. That's a safe optimization provided the following stand:

- You don't directly call the global **eval** function.
- You don't use the `with` statement.
- You don't access the `Function.name` property.

UglifyJS can detect the first two cases and it will disable the mangler automatically in code areas that are poisoned by usage of **eval** or `with`. UglifyJS *cannot* detect if you're using the function's **name** property, however; in such code the mangler can potentially break your code. For example the [JADE](http://jade-lang.com/) template engine is affected by this issue (coupled with its author [“I am the smartest and know what's best” attitude](https://github.com/visionmedia/jade/issues/298)).

### SYNOPSIS

```
ast = UglifyJS.parse(code);
ast.figure_out_scope();
ast.compute_char_frequency();
ast.mangle_names();
code = ast.print_to_string();
```

That's all there is to it. Make sure to call **figure_out_scope()** first, then call **mangle_names()** on the toplevel node. Optionally insert the **compute_char_frequency()** there to get names that are optimized for GZip compression (names will be generated using the most frequent characters first).

If you also [compress](http://lisperator.net/uglifyjs/compress) your code, then you want to mangle names *after* compression, since the compressor might drop unused identifiers, unreachable code etc. The full sequence would be this:

```js
ast = UglifyJS.parse(code);

// compressor needs figure_out_scope too
ast.figure_out_scope();
compressor = UglifyJS.Compressor()
ast = ast.transform(compressor);

// need to figure out scope again so mangler works optimally
ast.figure_out_scope();
ast.compute_char_frequency();
ast.mangle_names();

// get Ugly code back :)
code = ast.print_to_string();
```

## the code generator

The code generator is a recursive process of getting back source code from an AST returned by the parser. Every [AST node](http://lisperator.net/uglifyjs/ast#nodes) has a “print” method that takes an **OutputStream** and dumps the code from that node into it. The stream object supports a lot of options that control the output. You can specify whether you'd like to get human-readable (indented) output, the indentation level, whether you'd like to quote all properties in object literals etc.

代码生成器（The code generator）是一个递归过程，将 parser 生成的 AST 还原成源码。每个  [AST node](http://lisperator.net/uglifyjs/ast#nodes) 都有一个“print”方法，将当前节点通过 **OutputStream 输出出来。这个 stream 对象支持很多选项来控制输出。你可以指定是否希望获得人类可读的(缩进的)输出、缩进级别、是否要对对象字面量中的所有属性加引号等。

### 范例

```js
var stream = UglifyJS.OutputStream({ ...options... });
var code = ast.print(stream);
alert(stream.toString());
```

其中的 options 是一个对象。下面是默认选项：

```
indent_start  : 0,     // start indentation on every line (only when `beautify`)
indent_level  : 4,     // indentation level (only when `beautify`)
quote_keys    : false, // quote all keys in object literals?
space_colon   : true,  // add a space after colon signs?
ascii_only    : false, // output ASCII-safe? (encodes Unicode characters as ASCII)
inline_script : false, // escape "</script"?
width         : 80,    // informative maximum line width (for beautified output)
max_line_len  : 32000, // maximum line length (for non-beautified output)
ie_proof      : true,  // output IE-safe code?
beautify      : false, // beautify output?
source_map    : null,  // output a source map
bracketize    : false, // use brackets every time?
comments      : false, // output comments?
semicolons    : true,  // use semicolons to separate statements? (otherwise, newlines)
```

大多数都比较明显易懂。值得额外讨论的是 **source_map** 和 **comments**。

### Source map

输出流跟踪输出结果的的当前行/列，可以通过 Mozilla 的 [source-map](https://github.com/mozilla/source-map) 库生成对原始代码的source mapping。如果要使用这个功能，你必须加载这个库（在 NodeJs 版本自动引入，但是在浏览器环境，你必须手动引入），并且需要配置全局的 **MOZ_SourceMap** 。

接下来，在代码生成器的选项中，你需要传递 **UglifyJS.SourceMap**（对`source-map` 库的简单封装） 对象：

```js
var source_map = UglifyJS.SourceMap({ ...source_map_options... });
var stream = UglifyJS.OutputStream({
    ...
    source_map: source_map
});
ast.print(stream);

var code = stream.toString();
var map = source_map.toString(); // json output for your source map
```

The **source_map_options** is an optional JS object that you may pass to specify additional properties for your source map:

```
file : null, // the compressed file name
root : null, // the root URL to the original sources
orig : null, // the input source map
```

The **orig** is useful when you compress code that was generated from some other source (possibly other programming language). If you have an input source map, pass it in this argument (either as a JS object, or as a JSON string) and UglifyJS will generate a mapping that maps back to the original source (as opposed to the compiled code that you are compressing).

### Comments

The code generator can keep certain comments in the output. If you pass `comments: true` it'll keep all comments. You can pass a RegExp to retain only comments whose body matches that regexp. You can pass a function for custom filtering. For example, when `--comments` is passed with no argument the command-line tool will keep all comments containing "@license", "@preserve" or "@cc_on". Here is the function that it uses to filter them:

```
function(node, comment) {
    var text = comment.value;
    var type = comment.type;
    if (type == "comment2") {
        // multiline comment
        return /@preserve|@license|@cc_on/i.test(test);
    }
}
```

The code generator will pass two arguments: the **node** that the current comment is attached to, and the **comment** [token](http://lisperator.net/uglifyjs/ast#tokens).

Note that *some* comments might still be lost, due to compressor optimizations that cut whole nodes from the tree (for example unused function declarations). The safest place where to put comments that you might want to keep is at toplevel (not nested in brackets or functions).

## What's better than V1

First off, the code in version 2 is a lot bigger than V1. This isn't good news, but it happened for good reason. It's more modular and it doesn't use arrays, but objects instead, to represent [AST nodes](http://lisperator.net/uglifyjs/ast). The advantage is the ability to store location information and comments in the AST. Thanks to this, V2 is able to generate source maps[2](http://lisperator.net/blog/should-you-switch-to-uglifyjs2/#fn-2) or to retain certain comments in the output—features that were long requested but were extremely tricky to add on top of the first version.

Compression is more aggressive than in V1. V2 is able to discard mutually referencing functions if they are otherwise unused (which V1 didn't); it also discards unused variables or function arguments. It can detect a wider range of potential problems with the input files, such as “condition always true/false” etc. Also, it will work harder than V1 to reduce the number of statements, leading to potential removal of unnecessary brackets.

For these reasons it's a bit slower than V1, but not by much. Compression is a bit better, but again—not by much—and that's because the [most significant savings](http://lisperator.net/blog/javascript-minification-is-it-worth-it/) are due to renaming local variables and discarding whitespace. Everything else is fighting for mere bytes.
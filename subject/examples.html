<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端学习笔记 | 【译】通过例子解释 Debounce 和 Throttle</title>
    <meta name="description" content="前端学习笔记">
    
    
    <link rel="preload" href="/notebook/assets/css/24.styles.54e121d1.css" as="style"><link rel="preload" href="/notebook/assets/js/app.e422ee42.js" as="script"><link rel="preload" href="/notebook/assets/js/13.4a676149.js" as="script"><link rel="prefetch" href="/notebook/assets/js/1.0504529f.js"><link rel="prefetch" href="/notebook/assets/js/2.ff25ac17.js"><link rel="prefetch" href="/notebook/assets/js/3.3214ee55.js"><link rel="prefetch" href="/notebook/assets/js/4.91ed248e.js"><link rel="prefetch" href="/notebook/assets/js/5.f6d88800.js"><link rel="prefetch" href="/notebook/assets/js/6.196e425a.js"><link rel="prefetch" href="/notebook/assets/js/7.751555b3.js"><link rel="prefetch" href="/notebook/assets/js/8.f9163292.js"><link rel="prefetch" href="/notebook/assets/js/9.f8f2301a.js"><link rel="prefetch" href="/notebook/assets/js/10.daa165f6.js"><link rel="prefetch" href="/notebook/assets/js/11.6739d9ca.js"><link rel="prefetch" href="/notebook/assets/js/12.6a663263.js"><link rel="prefetch" href="/notebook/assets/js/0.af20d5dc.js"><link rel="prefetch" href="/notebook/assets/js/14.5b9129c1.js"><link rel="prefetch" href="/notebook/assets/js/15.578148e5.js"><link rel="prefetch" href="/notebook/assets/js/16.e904e7c8.js"><link rel="prefetch" href="/notebook/assets/js/17.51e48bca.js"><link rel="prefetch" href="/notebook/assets/js/18.b86da157.js"><link rel="prefetch" href="/notebook/assets/js/19.4d1f3647.js"><link rel="prefetch" href="/notebook/assets/js/20.db4d947d.js"><link rel="prefetch" href="/notebook/assets/js/21.c8cf075f.js"><link rel="prefetch" href="/notebook/assets/js/22.d56c9864.js"><link rel="prefetch" href="/notebook/assets/js/23.ef174104.js">
    <link rel="stylesheet" href="/notebook/assets/css/24.styles.54e121d1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/notebook/" class="home-link router-link-active"><!----><span class="site-name">
      前端学习笔记
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/notebook/tutorial/" class="nav-link">教程笔记</a></div><div class="nav-item"><a href="/notebook/subject/" class="nav-link router-link-active">专题</a></div><div class="nav-item"><a href="/notebook/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/notebook/question/" class="nav-link">题</a></div><div class="nav-item"><a href="/notebook/algorithm/" class="nav-link">算法</a></div><a href="https://github.com/athena0304/notebook" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notebook/tutorial/" class="nav-link">教程笔记</a></div><div class="nav-item"><a href="/notebook/subject/" class="nav-link router-link-active">专题</a></div><div class="nav-item"><a href="/notebook/basic/" class="nav-link">基础</a></div><div class="nav-item"><a href="/notebook/question/" class="nav-link">题</a></div><div class="nav-item"><a href="/notebook/algorithm/" class="nav-link">算法</a></div><a href="https://github.com/athena0304/notebook" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><a href="/notebook/subject/" class="sidebar-link">专题</a></li><li><a href="/notebook/subject/throttle-debouce.html" class="sidebar-link">throttle和debounce</a></li><li><a href="/notebook/subject/examples.html" class="active sidebar-link">【译】通过例子解释 Debounce 和 Throttle</a><ul class="sidebar-sub-headers"></ul></li></ul></div><div class="page"><div class="content"><h1 id="【译】通过例子解释-debounce-和-throttle"><a href="#【译】通过例子解释-debounce-和-throttle" aria-hidden="true" class="header-anchor">#</a> 【译】通过例子解释 Debounce 和 Throttle</h1><p><strong>Debounce</strong> 和 <strong>Throttle</strong> 是两个很相似但是又不同的技术，都可以控制一个函数在一段时间内执行的次数。</p><p>当我们在操作 DOM 事件的时候，为函数添加 debounce 或者 throttle 就会尤为有用。为什么？因为我们在事件和函数执行之间加了一个我们自己的控制层。记住，我们是不去控制这些 DOM 事件触发的频率的，因为这个可能会有变化。</p><p>下面我们以滚动事件举例：</p><iframe height="265" scrolling="no" title="Scroll events counter" src="//codepen.io/athena0304/embed/Yjbqar/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="allowfullscreen" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/Yjbqar/">Scroll events counter</a> by Athena (<a href="https://codepen.io/athena0304">@athena0304</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe><p>当使用触控板、鼠标滚轮，或者直接拽动滚动条，每秒都可以轻易触发至少30次事件，而且在触屏的移动端，甚至会达到每秒100次，面对这样高的执行频率，你的滚动事件处理程序能否很好地应对？</p><p>在2011年，Twitter 网站提出了一个 issue：当向下滚动 Twitter 信息流的时候，整个页面的响应速度都会变慢。 John Resig 基于该问题发表了一篇<a href="http://ejohn.org/blog/learning-from-twitter" target="_blank" rel="noopener noreferrer">博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，文中指出，直接在 <code>scroll</code> 事件里挂载一些计算量大的函数是件多么不明智的行为。</p><p>John 当时提出的解决方案是在 <code>onScroll event</code> 的外部设置一个每 250ms 执行一次的循环。这样处理程序就与事件解耦了。使用这样一个简单的技术就可以避免破坏用户体验。</p><div class="tip custom-block"><p class="custom-block-title">译者注</p><p>文中的核心代码如下</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> outerPane <span class="token operator">=</span> $details<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;.details-pane-outer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    didScroll <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scroll</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    didScroll <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> didScroll <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        didScroll <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// Check your page position and then</span>
        <span class="token comment">// Load in more results</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div><p>如今，处理事件的方式稍微复杂了一些。下面我们结合用例，一一介绍 Debounce、 Throttle 和requestAnimationFrame。</p><h3 id="debounce"><a href="#debounce" aria-hidden="true" class="header-anchor">#</a> Debounce</h3><p>Debounce 允许我们将多个连续的调用合并成一个。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/04/debounce.png" alt="img"></p><p>想象一个进电梯的场景，你走进了电梯，门刚要关上，这时另一个人想要进来，于是电梯没有移动楼层（处理函数），而是将门打开让那个人进来。这时又有一个人要进来，就又会上演刚才那一幕。也就是说，电梯延迟了它的函数（移动楼层）执行，但是优化了资源。</p><p>在下面的例子中，尝试快速点击按钮或者在上面滑动：</p><iframe height="265" scrolling="no" title="Debounce. Trailing" src="//codepen.io/athena0304/embed/NBVjRB/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="allowfullscreen" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/NBVjRB/">Debounce. Trailing</a> by Athena (<a href="https://codepen.io/athena0304">@athena0304</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe><p>你可以看到连续快速事件是怎样被一个单独的 debounce 事件所替代的。但是如果事件触发时间间隔较长，就不会发生 debounce。</p><h4 id="leading-边缘-或者-immediate"><a href="#leading-边缘-或者-immediate" aria-hidden="true" class="header-anchor">#</a> Leading 边缘 (或者 &quot;immediate&quot;)</h4><p>在上面的例子中，你会发现 debounce 事件会等到快速事件停止发生后才会触发函数执行。为什么不在每次一开始就立即触发函数执行呢，这样它的表现就和原始的没有去抖的处理器一样了。直到快速调用出现停顿的时候，才会再次触发。</p><p>下面是使用 <code>leading</code> 标识符的例子：</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/04/debounce-leading.png" alt="img"></p><p>在 underscore.js 中，该选项叫作 <code>immediate</code> ，而不是  <code>leading</code>。</p><p>自己试一下：</p><iframe height="265" scrolling="no" title="Debounce. Leading" src="//codepen.io/athena0304/embed/mGbgGo/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="allowfullscreen" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/mGbgGo/">Debounce. Leading</a> by Athena (<a href="https://codepen.io/athena0304">@athena0304</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe><h4 id="debounce-的实现"><a href="#debounce-的实现" aria-hidden="true" class="header-anchor">#</a> Debounce 的实现</h4><p>Debounce 的概念和实现最早是由 <a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank" rel="noopener noreferrer">John Hann<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 在2009年提出来的。</p><p>不久之后，Ben Alman 就写了一个 <a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="noopener noreferrer">jQuery 插件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（现在已经不再维护了），一年之后 Jeremy Ashkenas 把它添加进了 underscore.js。再后来被添加进 Lodash。</p><p>这三个实现在内部有一点不同，但是接口几乎是相同的。</p><p>曾经有一段时间，underscore 采取了 Lodash 里面的 debounce/throttle 实现，但是后来我在2013年发现了  <code>_.debounce</code> 函数的一个 bug。从那时起，这两种实现就出现分化了。</p><p>Lodash 为  <code>_.debounce</code> 和 <code>_.throttle</code>  添加了更多的特性。最初的  <code>immediate</code> 标识符被 <code>leading</code> 和 <code>trailing</code>所替代。你可以选择一个选项，也可以两个都要。默认情况下 <code>trailing</code> 是被开启的。</p><p>新的  <code>maxWait</code> 选项（目前只存在于Lodash）在本文中没有提及，但是它也是一个很有用的选项。实际上，throttle 函数就是使用  <code>_.debounce</code> 带着 <code>maxWait</code> 的选项来定义的，你可以在这里查看<a href="https://github.com/lodash/lodash/blob/4.8.0-npm/throttle.js" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h4 id="debounce-举例"><a href="#debounce-举例" aria-hidden="true" class="header-anchor">#</a> Debounce 举例</h4><h5 id="resize-举例"><a href="#resize-举例" aria-hidden="true" class="header-anchor">#</a> Resize 举例</h5><p>通过拖拽浏览器窗口，可以触发很多次 <code>resize</code> 事件。</p><p>例子如下：</p><iframe height="265" scrolling="no" title="Debounce Resize Event Example" src="//codepen.io/athena0304/embed/KxPLZy/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="allowfullscreen" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/KxPLZy/">Debounce Resize Event Example</a> by Athena (<a href="https://codepen.io/athena0304">@athena0304</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>
可以看到，我们在 resize 事件上使用的是默认的  `trailing` 选项，因为我们只需要关心用户停止调整浏览器后的最终结果就可以了。
<h5 id="敲击键盘，通过-ajax-请求自动填充表单"><a href="#敲击键盘，通过-ajax-请求自动填充表单" aria-hidden="true" class="header-anchor">#</a> 敲击键盘，通过 Ajax 请求自动填充表单</h5><p>为什么要在用户还在输入的时候每隔 50ms 就发送一次 Ajax请求？<code>_.debounce</code> 可以帮助我们避免额外的开销，只有当用户停止输入了再发送请求。</p><p>这里没有必要设置  <code>leading</code>，我们是想要等到最后一个字符输入完再执行函数的。</p><iframe height="265" scrolling="no" title="Debouncing keystrokes Example" src="//codepen.io/athena0304/embed/NLKVZw/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="allowfullscreen" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/NLKVZw/">Debouncing keystrokes Example</a> by Athena (<a href="https://codepen.io/athena0304">@athena0304</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>
还有一个类似的使用场景就是表单校验，当用户输入完再进行校验、提示信息等。
<h4 id="如何使用-debounce-和-throttle，以及常见问题"><a href="#如何使用-debounce-和-throttle，以及常见问题" aria-hidden="true" class="header-anchor">#</a> 如何使用 debounce 和 throttle，以及常见问题</h4><p>说了这么多，你可能已经想自己来写 debounce/throttle 函数了，或者是从网上随便一篇博客上拷贝一份下来。<strong>但是我给你的建议是直接使用 underscore 或者 Lodash。</strong> 如果你只是需要 <code>_.debounce</code> 和 <code>_.throttle</code> 函数，可以使用 <a href="https://lodash.com/custom-builds" target="_blank" rel="noopener noreferrer">Lodash custom builder<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来输出一个自定义的压缩后为 2KB 的库。可以使用下列命令来进行构建：</p><div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i -g lodash-cli
lodash include <span class="token operator">=</span> debounce, throttle
</code></pre></div><p>也就是说，最好是使用模块化的形式，通过 webpack/browserify/rollup 来引用，如 <code>lodash/throttle</code> 和 <code>lodash/debounce</code> 或 <code>lodash.throttle</code> 和 <code>lodash.debounce</code> 。</p><p>使用 <code>_.debounce</code> 函数的一个常见错误就是多次调用它：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 错误</span>
<span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 正确</span>
<span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>为 debounced 函数创建一个变量可以让我们调用私有函数 <code>debounced_version.cancel()</code>，如果有需要，lodash 和 underscore.js 都可以供你使用。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> debounced_version <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> debounced_version<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果你需要的话</span>
debounced_version<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="throttle"><a href="#throttle" aria-hidden="true" class="header-anchor">#</a> Throttle</h3><p>使用 <code>_.throttle</code> 则不允许函数每 X 毫秒的执行次数超过一次。</p><p>Throttle 和 debounce 最主要的区别就是 throttle 保证函数每 X 毫秒至少执行一次。</p><p>和 debounce 一样， throttle 也用在了 Ben 的插件、underscore.js 和 lodash里面。</p><h4 id="throttling-举例"><a href="#throttling-举例" aria-hidden="true" class="header-anchor">#</a> Throttling 举例</h4><h5 id="无限滚动"><a href="#无限滚动" aria-hidden="true" class="header-anchor">#</a> 无限滚动</h5><p>这是一个非常常见的例子。用户在一个无限滚动的页面里向下滚动，你需要知道当前滚动的位置距离底部还有多远，如果接近底部了，我们就得通过 Ajax 请求获取更多的内容，将其添加到页面里。</p><p>此时我们之前的 <code>_.debounce</code> 就派不上作用了。使用 debounce 只有当用户停止滚动时才能触发，而我们需要的是在用户滚动到底部之前就开始获取内容。</p><p>使用 <code>_.throttle</code> 就能确保实时检查距离底部还有多远。</p><h3 id="requestanimationframe-raf"><a href="#requestanimationframe-raf" aria-hidden="true" class="header-anchor">#</a> requestAnimationFrame (rAF)</h3><p><code>requestAnimationFrame</code> 是另一种限制函数执行速度的方法。</p><p>它可以被看做 <code>_.throttle(dosomething, 16)</code>。但它有着更高的保真度，因为它是浏览器的原生 API，有着更好的精度。</p><p>我们可以使用 rAF API，作为 throttle 函数的替代，考虑下面的优缺点：</p><h4 id="优点"><a href="#优点" aria-hidden="true" class="header-anchor">#</a> 优点</h4><ul><li>目标是 60fps（每帧 16ms），但是会在浏览器内部决定如何安排渲染的最佳时机。</li><li>非常简单，而且是标准 API，在未来也不会改变。更少的维护成本。</li></ul><h4 id="缺点"><a href="#缺点" aria-hidden="true" class="header-anchor">#</a> 缺点</h4><ul><li>rAFs 的开始/取消由我们自己来管理，而不像  <code>.debounce</code> 和 <code>.throttle</code> 是在内部管理的。</li><li>如果浏览器的 tab 页面不活跃了，它就不会再执行。</li><li>虽然所有的现代浏览器都提供了 rAF， 但是 IE9、Opera Mini 和一些老的安卓版本还不支持。如果需要，现在还是要使用 <a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener noreferrer">polyfill<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</li><li>Node.js 不支持 rAF，所以不能在服务端用于 throttle 文件系统事件。</li></ul><p>根据经验，如果你的 JavaScript 函数是在绘制或者直接改变属性，所有涉及到元素位置重新计算的，我会建议使用  <code>requestAnimationFrame</code>，</p><p>如果是处理 Ajax 请求，或者决定是否添加/删除某个 class（可能会触发一个 CSS 动画），我会考虑 <code>_.debounce</code> 和 <code>_.throttle</code>，这里可以设置更低一些的执行速度（例如 200ms，而不是16ms）。</p><p>这时你可能会想，为什不把 rAF 集成到 underscore 或 lodash 里呢，那他俩都是拒绝的，因为这只是一个特殊的使用场景，而且已经足够简单，可以被直接调用。</p><h4 id="raf-举例"><a href="#raf-举例" aria-hidden="true" class="header-anchor">#</a> rAF 举例</h4><p>受<a href="http://www.html5rocks.com/en/tutorials/speed/animations/" target="_blank" rel="noopener noreferrer">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的启发，在这里我会举一个滚动的例子，在这篇文章中有每个步骤的逻辑解释。</p><p>我做了一个对比实验，一边是 rAF，一边是 16ms 间隔的 <code>_.throttle</code>。它们性能很相似，但是 rAF 可能会在更复杂的场景下性能更高一些。</p><iframe height="265" scrolling="no" title="Scroll comparison requestAnimationFrame vs throttle" src="//codepen.io/dcorb/embed/pgOKKw/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="allowfullscreen" style="width: 100%;">See the Pen <a href="https://codepen.io/dcorb/pen/pgOKKw/">Scroll comparison requestAnimationFrame vs throttle</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe><p>还有一个更高级的例子，在 headroom.js 中，逻辑被<a href="https://github.com/WickyNilliams/headroom.js/blob/3282c23bc69b14f21bfbaf66704fa37b58e3241d/src/Debouncer.js" target="_blank" rel="noopener noreferrer">解耦<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了，并且包裹在了对象中。</p><h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3><p>使用 debounce、throttle 和  <code>requestAnimationFrame</code>  来优化你的事件处理程序。每种技术都有些许的不同，但是三个都是很有用的，而且能够互补。</p><p>总结：</p><ul><li><strong>debounce</strong>：将一系列迅速触发的事件（例如敲击键盘）合并成一个单独的事件。</li><li><strong>throttle</strong>：确保一个持续的操作流以每 X 毫秒执行一次的速度执行。例如每 200ms 检查一下滚动条的位置来触发某个 CSS 动画。</li><li><strong>requestAnimationFrame</strong>：throttle的一个替代品。适用于需要计算元素在屏幕上的位置和渲染的时候，能够保证动画或者变化的平滑性。注意：IE9 不支持。</li></ul><p>原文链接：https://css-tricks.com/debouncing-throttling-explained-examples/</p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/notebook/subject/throttle-debouce.html" class="prev">
          throttle和debounce
        </a></span><!----></p></div></div></div></div>
    <script src="/notebook/assets/js/13.4a676149.js" defer></script><script src="/notebook/assets/js/app.e422ee42.js" defer></script>
  </body>
</html>
